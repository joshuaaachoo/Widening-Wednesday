<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widening Wednesday</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        .webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .content-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 60px 40px;
            z-index: 10;
            pointer-events: none;
        }

        .content-overlay > * {
            pointer-events: auto;
        }

        .logo {
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 2px 2px 20px rgba(0,0,0,0.8);
        }

        .tagline {
            font-size: 1.5rem;
            margin-bottom: 30px;
            opacity: 0.9;
            text-shadow: 1px 1px 10px rgba(0,0,0,0.8);
        }

        .cta-buttons {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .cta-button {
            padding: 15px 35px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .cta-primary {
            background: linear-gradient(135deg, #1DB954, #1ed760);
            color: white;
        }

        .cta-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(29, 185, 84, 0.5);
        }

        .cta-secondary {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .cta-secondary:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-3px);
        }

        .album-info {
            position: fixed;
            top: 40px;
            right: 40px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px 30px;
            border-radius: 15px;
            max-width: 350px;
            z-index: 10;
            pointer-events: none;
        }

        .album-info h3 {
            font-size: 1.3rem;
            margin-bottom: 8px;
            color: #1DB954;
        }

        .album-info p {
            font-size: 1rem;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .album-info .added-by {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-top: 10px;
            font-style: italic;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        .loading i {
            font-size: 3rem;
            animation: spin 1s linear infinite;
            color: #1DB954;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .fallback-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 0;
        }

        @media (max-width: 768px) {
            .logo {
                font-size: 2.5rem;
            }

            .tagline {
                font-size: 1.2rem;
            }

            .content-overlay {
                padding: 40px 20px;
            }

            .album-info {
                top: 20px;
                right: 20px;
                left: 20px;
                max-width: none;
                padding: 15px 20px;
            }

            .cta-buttons {
                flex-direction: column;
            }

            .cta-button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <canvas class="webgl-canvas"></canvas>
    <div class="fallback-background" id="fallback" style="display: none;"></div>
    
    <div class="loading" id="loading">
        <i class="fas fa-spinner"></i>
    </div>

    <div class="content-overlay">
        <h1 class="logo">Widening Wednesday</h1>
        <p class="tagline">Discover and rate songs shared every Wednesday</p>
        <div class="cta-buttons">
            <a href="/rate.html" class="cta-button cta-primary">
                <i class="fas fa-star"></i> Rate Songs
            </a>
            <a href="/admin" class="cta-button cta-secondary">
                <i class="fas fa-plus"></i> Add Song
            </a>
        </div>
    </div>

    <div class="album-info" id="albumInfo">
        <h3 id="albumTitle">Loading...</h3>
        <p id="albumArtist">Artist</p>
        <p id="albumAlbum">Album</p>
        <p class="added-by" id="albumAddedBy">Added by</p>
    </div>

    <script type="module">
        import * as THREE from "https://esm.sh/three";

        let currentSlideIndex = 0;
        let isTransitioning = false;
        let shaderMaterial, renderer, scene, camera;
        let slideTextures = [];
        let albums = [];
        let autoSlideTimer = null;

        const TRANSITION_DURATION = 2.5;
        const AUTO_SLIDE_INTERVAL = 5000;

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture1;
            uniform sampler2D uTexture2;
            uniform float uProgress;
            uniform vec2 uResolution;
            uniform vec2 uTexture1Size;
            uniform vec2 uTexture2Size;
            
            varying vec2 vUv;

            vec2 getCoverUV(vec2 uv, vec2 textureSize) {
                vec2 s = uResolution / textureSize;
                float scale = max(s.x, s.y);
                vec2 scaledSize = textureSize * scale;
                vec2 offset = (uResolution - scaledSize) * 0.5;
                return (uv * uResolution - offset) / scaledSize;
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                
                return mix(
                    mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x),
                    mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x),
                    f.y
                );
            }

            vec4 glassEffect(vec2 uv, float progress) {
                float glassStrength = 0.08;
                float chromaticAberration = 0.02;
                
                vec2 center = vec2(0.5, 0.5);
                vec2 p = uv * uResolution;
                
                vec2 uv1 = getCoverUV(uv, uTexture1Size);
                vec2 uv2_base = getCoverUV(uv, uTexture2Size);
                
                float maxRadius = length(uResolution) * 0.85;
                float bubbleRadius = progress * maxRadius;
                vec2 sphereCenter = center * uResolution;
                
                float dist = length(p - sphereCenter);
                float normalizedDist = dist / max(bubbleRadius, 0.001);
                vec2 direction = (dist > 0.0) ? (p - sphereCenter) / dist : vec2(0.0);
                float inside = smoothstep(bubbleRadius + 3.0, bubbleRadius - 3.0, dist);
                
                float distanceFactor = smoothstep(0.3, 1.0, normalizedDist);
                float time = progress * 5.0;
                
                vec2 distortedUV = uv2_base;
                if (inside > 0.0) {
                    float refractionOffset = glassStrength * pow(distanceFactor, 1.5);
                    vec2 flowDirection = normalize(direction + vec2(sin(time), cos(time * 0.7)) * 0.3);
                    distortedUV -= flowDirection * refractionOffset;

                    float wave = sin(normalizedDist * 22.0 - time * 3.5);
                    float waveOffset = wave * 0.025 * distanceFactor;
                    distortedUV -= direction * waveOffset;
                }

                vec4 newImg;
                if (inside > 0.0) {
                    float aberrationOffset = chromaticAberration * pow(distanceFactor, 1.2);
                    
                    vec2 uv_r = distortedUV + direction * aberrationOffset * 1.2;
                    vec2 uv_g = distortedUV + direction * aberrationOffset * 0.2;
                    vec2 uv_b = distortedUV - direction * aberrationOffset * 0.8;

                    float r = texture2D(uTexture2, uv_r).r;
                    float g = texture2D(uTexture2, uv_g).g;
                    float b = texture2D(uTexture2, uv_b).b;
                    newImg = vec4(r, g, b, 1.0);
                } else {
                    newImg = texture2D(uTexture2, uv2_base);
                }
                
                vec4 currentImg = texture2D(uTexture1, uv1);
                
                if (progress > 0.95) {
                    vec4 pureNewImg = texture2D(uTexture2, uv2_base);
                    float endTransition = (progress - 0.95) / 0.05;
                    newImg = mix(newImg, pureNewImg, endTransition);
                }
                
                return mix(currentImg, newImg, inside);
            }

            void main() {
                gl_FragColor = glassEffect(vUv, uProgress);
            }
        `;

        async function loadAlbums() {
            try {
                const response = await fetch('/api/songs');
                const songs = await response.json();
                
                albums = songs.filter(song => song.image_url);
                
                if (albums.length === 0) {
                    document.getElementById('fallback').style.display = 'block';
                    document.getElementById('loading').style.display = 'none';
                    updateAlbumInfo({
                        title: 'No songs yet',
                        artist: 'Share some songs to get started!',
                        album: '',
                        added_by: ''
                    });
                    return false;
                }
                
                return true;
            } catch (error) {
                console.error('Error loading albums:', error);
                document.getElementById('fallback').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
                return false;
            }
        }

        async function loadImageTexture(src) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.TextureLoader();
                const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);
                
                loader.load(
                    src,
                    (texture) => {
                        clearTimeout(timeout);
                        texture.minFilter = texture.magFilter = THREE.LinearFilter;
                        texture.userData = {
                            size: new THREE.Vector2(texture.image.width, texture.image.height)
                        };
                        resolve(texture);
                    },
                    undefined,
                    (error) => {
                        clearTimeout(timeout);
                        reject(error);
                    }
                );
            });
        }

        async function initializeRenderer() {
            const canvas = document.querySelector('.webgl-canvas');
            if (!canvas) return;

            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: false,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTexture1: { value: null },
                    uTexture2: { value: null },
                    uProgress: { value: 0.0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uTexture1Size: { value: new THREE.Vector2(1, 1) },
                    uTexture2Size: { value: new THREE.Vector2(1, 1) }
                },
                vertexShader,
                fragmentShader
            });

            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, shaderMaterial);
            scene.add(mesh);

            // Load all textures
            for (let i = 0; i < albums.length; i++) {
                try {
                    const texture = await loadImageTexture(albums[i].image_url);
                    slideTextures.push(texture);
                } catch (error) {
                    console.warn(`Failed to load image ${i}`);
                }
            }

            if (slideTextures.length >= 2) {
                shaderMaterial.uniforms.uTexture1.value = slideTextures[0];
                shaderMaterial.uniforms.uTexture2.value = slideTextures[1];
                shaderMaterial.uniforms.uTexture1Size.value = slideTextures[0].userData.size;
                shaderMaterial.uniforms.uTexture2Size.value = slideTextures[1].userData.size;
                
                updateAlbumInfo(albums[0]);
                document.getElementById('loading').style.display = 'none';
                
                startAutoSlide();
            }

            const render = () => {
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            };
            render();
        }

        function updateAlbumInfo(album) {
            document.getElementById('albumTitle').textContent = album.title || 'Unknown Title';
            document.getElementById('albumArtist').textContent = album.artist || 'Unknown Artist';
            document.getElementById('albumAlbum').textContent = album.album || '';
            document.getElementById('albumAddedBy').textContent = album.added_by ? `Added by ${album.added_by}` : '';
        }

        function navigateToSlide(targetIndex) {
            if (isTransitioning || targetIndex === currentSlideIndex || !slideTextures[targetIndex]) return;
            
            stopAutoSlide();
            
            const currentTexture = slideTextures[currentSlideIndex];
            const targetTexture = slideTextures[targetIndex];
            
            isTransitioning = true;
            
            shaderMaterial.uniforms.uTexture1.value = currentTexture;
            shaderMaterial.uniforms.uTexture2.value = targetTexture;
            shaderMaterial.uniforms.uTexture1Size.value = currentTexture.userData.size;
            shaderMaterial.uniforms.uTexture2Size.value = targetTexture.userData.size;
            
            currentSlideIndex = targetIndex;
            updateAlbumInfo(albums[currentSlideIndex]);
            
            gsap.fromTo(
                shaderMaterial.uniforms.uProgress,
                { value: 0 },
                {
                    value: 1,
                    duration: TRANSITION_DURATION,
                    ease: "power2.inOut",
                    onComplete: () => {
                        shaderMaterial.uniforms.uProgress.value = 0;
                        shaderMaterial.uniforms.uTexture1.value = targetTexture;
                        shaderMaterial.uniforms.uTexture1Size.value = targetTexture.userData.size;
                        isTransitioning = false;
                        startAutoSlide();
                    }
                }
            );
        }

        function startAutoSlide() {
            stopAutoSlide();
            autoSlideTimer = setTimeout(() => {
                const nextIndex = (currentSlideIndex + 1) % albums.length;
                navigateToSlide(nextIndex);
            }, AUTO_SLIDE_INTERVAL);
        }

        function stopAutoSlide() {
            if (autoSlideTimer) {
                clearTimeout(autoSlideTimer);
                autoSlideTimer = null;
            }
        }

        // Click to advance
        document.addEventListener('click', (e) => {
            if (e.target.closest('.content-overlay')) return;
            if (!isTransitioning && slideTextures.length > 0) {
                const nextIndex = (currentSlideIndex + 1) % albums.length;
                navigateToSlide(nextIndex);
            }
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.code === 'ArrowRight' || e.code === 'Space') {
                e.preventDefault();
                if (!isTransitioning && slideTextures.length > 0) {
                    const nextIndex = (currentSlideIndex + 1) % albums.length;
                    navigateToSlide(nextIndex);
                }
            } else if (e.code === 'ArrowLeft') {
                e.preventDefault();
                if (!isTransitioning && slideTextures.length > 0) {
                    const prevIndex = (currentSlideIndex - 1 + albums.length) % albums.length;
                    navigateToSlide(prevIndex);
                }
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            if (renderer && shaderMaterial) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                shaderMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            }
        });

        // Touch support
        let touchStartX = 0;
        let touchEndX = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            if (Math.abs(touchEndX - touchStartX) < 50) return;
            
            if (touchEndX < touchStartX && !isTransitioning) {
                const nextIndex = (currentSlideIndex + 1) % albums.length;
                navigateToSlide(nextIndex);
            } else if (touchEndX > touchStartX && !isTransitioning) {
                const prevIndex = (currentSlideIndex - 1 + albums.length) % albums.length;
                navigateToSlide(prevIndex);
            }
        });

        // Visibility change handler
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopAutoSlide();
            } else if (!isTransitioning && slideTextures.length > 0) {
                startAutoSlide();
            }
        });

        // Initialize
        window.addEventListener('load', async () => {
            const hasAlbums = await loadAlbums();
            if (hasAlbums) {
                await initializeRenderer();
            }
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Widening Wednesday</title>
    <!-- simple redirect to home.html so platforms expecting public/index.html work -->
    <meta http-equiv="refresh" content="0; url=/home.html" />
    <link rel="canonical" href="/home.html">
    <style>html,body{height:100%;margin:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}</style>
  </head>
  <body>
    <div>
      Redirecting to <a href="/home.html" style="color:#1DB954">/home.html</a>
    </div>
  </body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widening Wednesday</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .songs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .song-card {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .song-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .song-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #1DB954, #1ed760);
        }

        .song-info {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .song-image {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            margin-right: 15px;
            object-fit: cover;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .song-details h3 {
            font-size: 1.3rem;
            margin-bottom: 5px;
            color: #333;
        }

        .song-details h3 a {
            color: #1DB954;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .song-details h3 a:hover {
            color: #1ed760;
            text-decoration: underline;
        }

        .song-details p {
            color: #666;
            font-size: 1rem;
        }

        .rating-section {
            margin-bottom: 20px;
        }

        .rating-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .rating-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rating-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .rating-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1DB954;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .rating-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1DB954;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }

        .rating-value {
            font-weight: bold;
            font-size: 1.2rem;
            color: #1DB954;
            min-width: 30px;
            text-align: center;
        }

        .review-section {
            margin-bottom: 20px;
        }

        .review-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 80px;
            transition: border-color 0.3s ease;
        }

        .review-textarea:focus {
            outline: none;
            border-color: #1DB954;
        }

        .submit-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #1DB954, #1ed760);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(29, 185, 84, 0.4);
        }

        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            font-size: 0.9rem;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: white;
            font-size: 1.2rem;
        }

        .loading i {
            font-size: 2rem;
            margin-bottom: 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: white;
        }

        .empty-state i {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.7;
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .empty-state p {
            font-size: 1.1rem;
            opacity: 0.8;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #c3e6cb;
            display: none;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
            display: none;
        }

        .user-rating-info {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 10px 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #c8e6c9;
            font-size: 0.9rem;
            display: none;
        }

        .user-rating-info i {
            margin-right: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .songs-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .song-card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Widening Wednesday</h1>
            <p>Rate the songs shared every Wednesday!</p>
            <div id="user-auth" style="margin-top:20px;"></div>
        </div>

        <div id="loading" class="loading">
            <i class="fas fa-spinner"></i>
            <div>Loading songs...</div>
        </div>

        <div id="empty-state" class="empty-state" style="display: none;">
            <i class="fas fa-music"></i>
            <h3>No songs to rate yet</h3>
            <p>Check back on Wednesday when new songs are shared!</p>
        </div>

        <div id="songs-container" class="songs-grid" style="display: none;">
            <!-- Songs will be populated here -->
        </div>
    </div>

    <script>
        let currentUser = null;
        async function fetchUser() {
            try {
                const res = await fetch('/api/me');
                if (res.ok) {
                    currentUser = await res.json();
                } else {
                    currentUser = null;
                }
            } catch {
                currentUser = null;
            }
            renderAuthUI();
        }
        function renderAuthUI() {
            const el = document.getElementById('user-auth');
            if (!currentUser) {
                el.innerHTML = `<a href="/auth/discord" class="submit-btn" style="display:inline-block;width:auto;padding:8px 18px;font-size:1rem;"><i class="fab fa-discord"></i> Login with Discord</a>`;
            } else {
                el.innerHTML = `
                    <span style="color:#1DB954;font-weight:bold;">Logged in as <i class="fab fa-discord"></i> ${currentUser.username}#${currentUser.discriminator}</span>
                    <a href="/logout" class="submit-btn" style="display:inline-block;width:auto;padding:8px 18px;font-size:1rem;margin-left:15px;background:#e74c3c;">Logout</a>
                `;
            }
        }
        fetchUser();
        class SpotifyRater {
            constructor() {
                this.songs = [];
                this.userId = null; // Will be Discord user id if logged in
                this.init();
            }

            async init() {
                await fetchUser();
                if (currentUser) {
                    this.userId = currentUser.id;
                }
                await this.loadSongs();
                this.setupAutoRefresh();
            }

            async loadSongs() {
                try {
                    const response = await fetch('/api/songs');
                    this.songs = await response.json();
                    this.renderSongs();
                } catch (error) {
                    console.error('Error loading songs:', error);
                    this.showError('Failed to load songs. Please refresh the page.');
                }
            }

            async renderSongs() {
                const loadingEl = document.getElementById('loading');
                const emptyStateEl = document.getElementById('empty-state');
                const songsContainerEl = document.getElementById('songs-container');

                loadingEl.style.display = 'none';

                if (this.songs.length === 0) {
                    emptyStateEl.style.display = 'block';
                    songsContainerEl.style.display = 'none';
                    return;
                }

                emptyStateEl.style.display = 'none';
                songsContainerEl.style.display = 'grid';

                songsContainerEl.innerHTML = this.songs.map(song => this.createSongCard(song)).join('');
                // Check if user has rated each song
                for (const song of this.songs) {
                    await this.checkUserRating(song.id);
                }
            }

            createSongCard(song) {
                const ratingCount = song.rating_count || 0;
                let disabled = !currentUser ? 'disabled' : '';
                let loginMsg = !currentUser ? '<div style="color:#e74c3c;font-weight:bold;margin-bottom:10px;">Login with Discord to rate!</div>' : '';
                return `
                    <div class="song-card" data-song-id="${song.id}">
                        <div class="song-info">
                            ${song.image_url ? `<img src="${song.image_url}" alt="${song.title}" class="song-image">` : '<div class="song-image" style="background: #f0f0f0; display: flex; align-items: center; justify-content: center;"><i class="fas fa-music" style="color: #ccc; font-size: 2rem;"></i></div>'}
                        <div class="song-details">
                            <h3><a href="${song.spotify_url}" target="_blank">${song.title || 'Unknown Title'}</a></h3>
                            <p>${song.artist || 'Unknown Artist'}</p>
                        </div>
                        </div>
                        <div class="rating-section">
                            ${loginMsg}
                            <label class="rating-label">Rate this song (1-7):</label>
                            <div class="rating-input">
                                <input type="range" 
                                       class="rating-slider" 
                                       min="1" 
                                       max="7" 
                                       value="4" 
                                       data-song-id="${song.id}"
                                       oninput="this.nextElementSibling.textContent = this.value"
                                       ${disabled}>
                                <span class="rating-value">4</span>
                            </div>
                        </div>
                        <div class="review-section">
                            <label class="rating-label">Optional Review:</label>
                            <textarea class="review-textarea" 
                                      placeholder="Share your thoughts about this song..." 
                                      data-song-id="${song.id}" ${disabled}></textarea>
                        </div>
                        <button class="submit-btn" onclick="rater.submitRating(${song.id})" ${disabled}>
                            <i class="fas fa-star"></i> Submit Rating
                        </button>
                        <div class="stats">
                            <span><i class="fas fa-users"></i> ${ratingCount} rating${ratingCount !== 1 ? 's' : ''}</span>
                        </div>
                        <div class="success-message" id="success-${song.id}">
                            <i class="fas fa-check-circle"></i> Rating submitted successfully!
                        </div>
                        <div class="error-message" id="error-${song.id}">
                            <i class="fas fa-exclamation-circle"></i> <span class="error-text"></span>
                        </div>
                        <div class="user-rating-info" id="user-rating-${song.id}">
                            <i class="fas fa-check-circle"></i> <span class="rating-text"></span>
                        </div>
                    </div>
                `;
            }

            async submitRating(songId) {
                if (!currentUser) {
                    alert('You must be logged in with Discord to rate.');
                    return;
                }
                const card = document.querySelector(`[data-song-id="${songId}"]`);
                const ratingSlider = card.querySelector('.rating-slider');
                const reviewTextarea = card.querySelector('.review-textarea');
                const submitBtn = card.querySelector('.submit-btn');
                const successMsg = card.querySelector('.success-message');
                const errorMsg = card.querySelector('.error-message');

                const rating = parseInt(ratingSlider.value);
                const review = reviewTextarea.value.trim();

                // Disable button and show loading
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Submitting...';
                this.hideMessages(songId);

                try {
                    const response = await fetch(`/api/songs/${songId}/rate`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            user_id: currentUser.id,
                            rating: rating,
                            review: review || null
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        successMsg.innerHTML = `<i class="fas fa-check-circle"></i> Rating ${result.updated ? 'updated' : 'submitted'} successfully!`;
                        successMsg.style.display = 'block';
                        // Clear form
                        ratingSlider.value = 4;
                        ratingSlider.nextElementSibling.textContent = '4';
                        reviewTextarea.value = '';
                        // Update user rating info
                        await this.checkUserRating(songId);
                        // Reload songs to update stats
                        setTimeout(() => this.loadSongs(), 1000);
                    } else {
                        const errorData = await response.json();
                        this.showError(songId, errorData.error || 'Failed to submit rating');
                    }
                } catch (error) {
                    console.error('Error submitting rating:', error);
                    this.showError(songId, 'Network error. Please try again.');
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '<i class="fas fa-star"></i> Submit Rating';
                }
            }

            showError(songId, message) {
                const errorMsg = document.getElementById(`error-${songId}`);
                const errorText = errorMsg.querySelector('.error-text');
                errorText.textContent = message;
                errorMsg.style.display = 'block';
            }

            hideMessages(songId) {
                const successMsg = document.getElementById(`success-${songId}`);
                const errorMsg = document.getElementById(`error-${songId}`);
                successMsg.style.display = 'none';
                errorMsg.style.display = 'none';
            }

            async checkUserRating(songId) {
                try {
                    const response = await fetch(`/api/songs/${songId}/ratings`);
                    const ratings = await response.json();
                    // Find if current user has rated
                    if (!currentUser) return;
                    const userRating = ratings.find(r => r.user_id === currentUser.id);
                    if (userRating) {
                        const userRatingInfo = document.getElementById(`user-rating-${songId}`);
                        const ratingText = userRatingInfo.querySelector('.rating-text');
                        const timestamp = this.formatTimestamp(userRating.created_at);
                        ratingText.textContent = `You rated this ${userRating.rating}/7 ${timestamp}`;
                        userRatingInfo.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error checking user rating:', error);
                }
            }

            formatTimestamp(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);
                if (diffMins < 1) return 'just now';
                if (diffMins < 60) return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
                if (diffHours < 24) return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
                if (diffDays < 7) return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
                return 'on ' + date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            }

            setupAutoRefresh() {
                setInterval(() => {
                    this.loadSongs();
                }, 30000);
            }
        }

        // Initialize the app
        const rater = new SpotifyRater();
    </script>
</body>
</html>
